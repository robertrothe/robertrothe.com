    <!-- ... (Ihr HTML- und CSS-Code bleibt unverändert) ... -->
    <script>
        // --- ASCII-Animation (unverändert) ---
        const canvas = document.getElementById("ascii-canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const CHARS = ["@", "#", "S", "%", "?", "*", "+", ";", ":", ",", "."];
        const FRAME_RATE = 30;
        const CHAR_SIZE = 10;
        let frameNumber = 0;

        function generateFrame() {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < canvas.height; y += CHAR_SIZE) {
                for (let x = 0; x < canvas.width; x += CHAR_SIZE) {
                    const charIndex = Math.floor((Math.sin(x / 50 + frameNumber / 10) + 1) * (CHARS.length - 1) / 2);
                    const char = CHARS[charIndex];
                    const r = Math.floor((Math.sin(x / 100 + frameNumber / 20) + 1) * 127);
                    const g = Math.floor((Math.cos(y / 100 + frameNumber / 20) + 1) * 127);
                    const b = Math.floor((Math.sin((x + y) / 100 + frameNumber / 20) + 1) * 127);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillText(char, x, y);
                }
            }
            frameNumber++;
        }
        setInterval(generateFrame, 1000 / FRAME_RATE);
        ctx.font = `${CHAR_SIZE}px monospace`;
        ctx.textAlign = "left";
        ctx.textBaseline = "top";

        // --- VERBESSERTE Spracherkennung mit robuster Neustart-Logik ---
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const downloadBtn = document.getElementById("downloadBtn");
        const transcriptDiv = document.getElementById("transcript");

        let recognition;
        let finalTranscript = "";
        let isRecording = false; // Dieser Status ist der "Wunsch" des Benutzers

        function correctGermanSpecialCharacters(text) {
            return text
                .replace(/Ã¤/g, "ä").replace(/Ã„/g, "Ä")
                .replace(/Ã¶/g, "ö").replace(/Ã–/g, "Ö")
                .replace(/Ã¼/g, "ü").replace(/Ãœ/g, "Ü")
                .replace(/ÃŸ/g, "ß");
        }
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = "de-DE";

            recognition.onresult = (event) => {
                let interimTranscript = "";
                let currentFinalTranscript = ""; // Nur das finale Ergebnis dieses Durchgangs
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        currentFinalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                
                // Füge den finalen Teil zum Gesamt-Transkript hinzu und stelle es dar
                finalTranscript += correctGermanSpecialCharacters(currentFinalTranscript);
                transcriptDiv.innerHTML = `<p>${finalTranscript}<span class="interim">${correctGermanSpecialCharacters(interimTranscript)}</span></p>`;
                transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
            };

            // NEUE `onerror`-Logik: Nur noch zur Fehleranzeige
            recognition.onerror = (event) => {
                console.error("Fehler bei der Spracherkennung:", event.error);
                // Wichtige Fehler für den Benutzer anzeigen
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    // Stoppen, da der Fehler nicht behoben werden kann ohne Nutzeraktion
                    isRecording = false; 
                    updateButtonStates();
                    transcriptDiv.innerHTML += `<p style="color:red;">Fehler: Mikrofonzugriff wurde verweigert. Bitte erlauben Sie den Zugriff und laden Sie die Seite neu.</p>`;
                } else if (event.error === 'network') {
                    // Dies ist ein erwarteter Fehler (Timeout), wird durch onend behandelt
                    console.log("Netzwerk-Timeout, `onend` wird den Neustart übernehmen.");
                } else {
                    transcriptDiv.innerHTML += `<p style="color:orange;">Fehler: ${event.error}.</p>`;
                }
            };
            
            // NEUE `onend`-Logik: Der Schlüssel zur Stabilität
            recognition.onend = () => {
                console.log("Spracherkennung beendet.");
                // Wenn der Benutzer die Aufnahme nicht aktiv gestoppt hat,
                // war es ein Timeout -> also neu starten.
                if (isRecording) {
                    console.log("Aufnahme ist noch aktiv, starte Erkennung neu...");
                    recognition.start(); // Sicherer Neustart hier
                }
            };

            function startRecording() {
                // Leert das Transkript bei jedem neuen Start
                finalTranscript = ""; 
                transcriptDiv.innerHTML = "<p>Aufnahme gestartet... bitte sprechen.</p>";
                isRecording = true;
                recognition.start();
                updateButtonStates();
                console.log("Aufnahme vom Benutzer gestartet...");
            }

            function stopRecording() {
                isRecording = false; // Der Benutzer möchte stoppen
                recognition.stop(); // Löst `onend` aus, aber `isRecording` ist `false`
                updateButtonStates();
                console.log("Aufnahme vom Benutzer gestoppt.");
            }
            
            function updateButtonStates() {
                startBtn.disabled = isRecording;
                stopBtn.disabled = !isRecording;
                downloadBtn.disabled = isRecording || finalTranscript.trim().length === 0;
                
                if (!isRecording && finalTranscript.trim().length > 0) {
                     transcriptDiv.innerHTML += `<p>Aufnahme gestoppt.</p>`;
                }
            }

            startBtn.addEventListener("click", startRecording);
            stopBtn.addEventListener("click", stopRecording);

            downloadBtn.addEventListener("click", () => {
                const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
                const filename = `transkript-${timestamp}.txt`;
                const blob = new Blob([finalTranscript.trim()], { type: "text/plain;charset=UTF-8" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });

        } else {
            transcriptDiv.innerHTML = "<p>Ihr Browser unterstützt die Web Speech API leider nicht. Bitte versuchen Sie es mit Google Chrome.</p>";
            startBtn.disabled = true;
            stopBtn.disabled = true;
        }

        // --- Korrigierte Gemini Integration (unverändert zur letzten Version) ---
        // ... (Der Gemini-Teil des Skripts bleibt hier wie er war) ...
        const toggleGeminiConfigBtn = document.getElementById("toggleGeminiConfigBtn");
        const geminiConfigSection = document.getElementById("geminiConfigSection");
        const geminiApiKeyInput = document.getElementById("geminiApiKey");
        const geminiModelNameInput = document.getElementById("geminiModelName");
        const summarizeBtn = document.getElementById("summarizeBtn");
        const downloadGeminiBtn = document.getElementById("downloadGeminiBtn");
        const geminiResultsContainer = document.getElementById("geminiResultsContainer");
        let geminiSummary = "";
        toggleGeminiConfigBtn.addEventListener("click", () => {
            const isHidden = geminiConfigSection.style.display === "none";
            geminiConfigSection.style.display = isHidden ? "block" : "none";
            toggleGeminiConfigBtn.textContent = isHidden ? "[ Hide Configuration ]" : "[ Configure & Summarize with Gemini ]";
        });
        async function processGeminiSummarization() {
            const apiKey = geminiApiKeyInput.value.trim();
            const modelName = geminiModelNameInput.value.trim();
            const currentTranscript = finalTranscript.trim();
            geminiResultsContainer.innerHTML = "";
            downloadGeminiBtn.style.display = "none";
            if (!apiKey) {
                geminiResultsContainer.innerHTML = "<p style='color: red;'>Fehler: Gemini API Key fehlt.</p>";
                return;
            }
            if (!modelName) {
                geminiResultsContainer.innerHTML = "<p style='color: red;'>Fehler: Gemini Model Name fehlt.</p>";
                return;
            }
            if (!currentTranscript) {
                geminiResultsContainer.innerHTML = "<p style='color: red;'>Fehler: Das Transkript ist leer. Bitte nehmen Sie zuerst Audio auf.</p>";
                return;
            }
            geminiResultsContainer.innerHTML = "<p>Verarbeite mit Gemini... Dies kann einen Moment dauern.</p>";
            summarizeBtn.disabled = true;
            const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(geminiApiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: "Fasse den folgenden Text professionell und strukturiert auf Deutsch zusammen. Erstelle am Ende eine Liste mit 3-5 passenden Kategorien oder Schlagwörtern:\n\n---\n" + currentTranscript
                            }]
                        }]
                    }),
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API-Fehler: ${response.status} - ${errorData.error.message}`);
                }
                const data = await response.json();
                if (data.candidates && data.candidates[0].content.parts[0].text) {
                    geminiSummary = data.candidates[0].content.parts[0].text;
                    geminiResultsContainer.innerHTML = `<strong>Zusammenfassung & Kategorien:</strong><br><br>${geminiSummary}`;
                    downloadGeminiBtn.style.display = "inline-block";
                } else {
                    throw new Error("Unerwartete Antwortstruktur von der Gemini API.");
                }
            } catch (error) {
                geminiResultsContainer.innerHTML = `<p style='color: red;'>Fehler bei der Anfrage: ${error.message}</p>`;
                console.error("Fehler beim Gemini API-Aufruf:", error);
            } finally {
                summarizeBtn.disabled = false;
            }
        }
        summarizeBtn.addEventListener("click", processGeminiSummarization);
        downloadGeminiBtn.addEventListener("click", () => {
             if (!geminiSummary) {
                alert("Keine Gemini-Ausgabe zum Herunterladen vorhanden.");
                return;
            }
            const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
            const filename = `gemini-zusammenfassung-${timestamp}.txt`;
            const blob = new Blob([geminiSummary], { type: "text/plain;charset=UTF-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>
